// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"singo/dal/sql_model"
)

func newKmExpansionKeyword(db *gorm.DB, opts ...gen.DOOption) kmExpansionKeyword {
	_kmExpansionKeyword := kmExpansionKeyword{}

	_kmExpansionKeyword.kmExpansionKeywordDo.UseDB(db, opts...)
	_kmExpansionKeyword.kmExpansionKeywordDo.UseModel(&sql_model.KmExpansionKeyword{})

	tableName := _kmExpansionKeyword.kmExpansionKeywordDo.TableName()
	_kmExpansionKeyword.ALL = field.NewAsterisk(tableName)
	_kmExpansionKeyword.ID = field.NewInt64(tableName, "id")
	_kmExpansionKeyword.Keyword = field.NewString(tableName, "keyword")
	_kmExpansionKeyword.TaskID = field.NewInt64(tableName, "task_id")
	_kmExpansionKeyword.BusinessID = field.NewInt64(tableName, "business_id")
	_kmExpansionKeyword.RootKeyword = field.NewString(tableName, "root_keyword")
	_kmExpansionKeyword.ParentKeyword = field.NewString(tableName, "parent_keyword")
	_kmExpansionKeyword.CrawlLevel = field.NewInt32(tableName, "crawl_level")
	_kmExpansionKeyword.KeywordSource = field.NewInt32(tableName, "keyword_source")
	_kmExpansionKeyword.IsSubmitted = field.NewBool(tableName, "is_submitted")
	_kmExpansionKeyword.IsCandidateDone = field.NewBool(tableName, "is_candidate_done")
	_kmExpansionKeyword.IsRelatedDone = field.NewBool(tableName, "is_related_done")
	_kmExpansionKeyword.IsExpanded = field.NewBool(tableName, "is_expanded")
	_kmExpansionKeyword.CreatedAt = field.NewTime(tableName, "created_at")
	_kmExpansionKeyword.UpdatedAt = field.NewTime(tableName, "updated_at")

	_kmExpansionKeyword.fillFieldMap()

	return _kmExpansionKeyword
}

type kmExpansionKeyword struct {
	kmExpansionKeywordDo kmExpansionKeywordDo

	ALL             field.Asterisk
	ID              field.Int64  // 关键词id,递增
	Keyword         field.String // 关键词
	TaskID          field.Int64  // 任务id
	BusinessID      field.Int64  // 业务id
	RootKeyword     field.String // 根词
	ParentKeyword   field.String // 父词
	CrawlLevel      field.Int32  // 当前所属抓取层级
	KeywordSource   field.Int32  // 关键词来源，0-根词默认，1-来源candidate，2-来源related
	IsSubmitted     field.Bool   // 是否提交
	IsCandidateDone field.Bool   // 候选词是否已就绪
	IsRelatedDone   field.Bool   // 关联词是否已就绪
	IsExpanded      field.Bool   // 是否处理完毕
	CreatedAt       field.Time   // 创建时间
	UpdatedAt       field.Time   // 更新时间

	fieldMap map[string]field.Expr
}

func (k kmExpansionKeyword) Table(newTableName string) *kmExpansionKeyword {
	k.kmExpansionKeywordDo.UseTable(newTableName)
	return k.updateTableName(newTableName)
}

func (k kmExpansionKeyword) As(alias string) *kmExpansionKeyword {
	k.kmExpansionKeywordDo.DO = *(k.kmExpansionKeywordDo.As(alias).(*gen.DO))
	return k.updateTableName(alias)
}

func (k *kmExpansionKeyword) updateTableName(table string) *kmExpansionKeyword {
	k.ALL = field.NewAsterisk(table)
	k.ID = field.NewInt64(table, "id")
	k.Keyword = field.NewString(table, "keyword")
	k.TaskID = field.NewInt64(table, "task_id")
	k.BusinessID = field.NewInt64(table, "business_id")
	k.RootKeyword = field.NewString(table, "root_keyword")
	k.ParentKeyword = field.NewString(table, "parent_keyword")
	k.CrawlLevel = field.NewInt32(table, "crawl_level")
	k.KeywordSource = field.NewInt32(table, "keyword_source")
	k.IsSubmitted = field.NewBool(table, "is_submitted")
	k.IsCandidateDone = field.NewBool(table, "is_candidate_done")
	k.IsRelatedDone = field.NewBool(table, "is_related_done")
	k.IsExpanded = field.NewBool(table, "is_expanded")
	k.CreatedAt = field.NewTime(table, "created_at")
	k.UpdatedAt = field.NewTime(table, "updated_at")

	k.fillFieldMap()

	return k
}

func (k *kmExpansionKeyword) WithContext(ctx context.Context) *kmExpansionKeywordDo {
	return k.kmExpansionKeywordDo.WithContext(ctx)
}

func (k kmExpansionKeyword) TableName() string { return k.kmExpansionKeywordDo.TableName() }

func (k kmExpansionKeyword) Alias() string { return k.kmExpansionKeywordDo.Alias() }

func (k kmExpansionKeyword) Columns(cols ...field.Expr) gen.Columns {
	return k.kmExpansionKeywordDo.Columns(cols...)
}

func (k *kmExpansionKeyword) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := k.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (k *kmExpansionKeyword) fillFieldMap() {
	k.fieldMap = make(map[string]field.Expr, 14)
	k.fieldMap["id"] = k.ID
	k.fieldMap["keyword"] = k.Keyword
	k.fieldMap["task_id"] = k.TaskID
	k.fieldMap["business_id"] = k.BusinessID
	k.fieldMap["root_keyword"] = k.RootKeyword
	k.fieldMap["parent_keyword"] = k.ParentKeyword
	k.fieldMap["crawl_level"] = k.CrawlLevel
	k.fieldMap["keyword_source"] = k.KeywordSource
	k.fieldMap["is_submitted"] = k.IsSubmitted
	k.fieldMap["is_candidate_done"] = k.IsCandidateDone
	k.fieldMap["is_related_done"] = k.IsRelatedDone
	k.fieldMap["is_expanded"] = k.IsExpanded
	k.fieldMap["created_at"] = k.CreatedAt
	k.fieldMap["updated_at"] = k.UpdatedAt
}

func (k kmExpansionKeyword) clone(db *gorm.DB) kmExpansionKeyword {
	k.kmExpansionKeywordDo.ReplaceConnPool(db.Statement.ConnPool)
	return k
}

func (k kmExpansionKeyword) replaceDB(db *gorm.DB) kmExpansionKeyword {
	k.kmExpansionKeywordDo.ReplaceDB(db)
	return k
}

type kmExpansionKeywordDo struct{ gen.DO }

func (k kmExpansionKeywordDo) Debug() *kmExpansionKeywordDo {
	return k.withDO(k.DO.Debug())
}

func (k kmExpansionKeywordDo) WithContext(ctx context.Context) *kmExpansionKeywordDo {
	return k.withDO(k.DO.WithContext(ctx))
}

func (k kmExpansionKeywordDo) ReadDB() *kmExpansionKeywordDo {
	return k.Clauses(dbresolver.Read)
}

func (k kmExpansionKeywordDo) WriteDB() *kmExpansionKeywordDo {
	return k.Clauses(dbresolver.Write)
}

func (k kmExpansionKeywordDo) Session(config *gorm.Session) *kmExpansionKeywordDo {
	return k.withDO(k.DO.Session(config))
}

func (k kmExpansionKeywordDo) Clauses(conds ...clause.Expression) *kmExpansionKeywordDo {
	return k.withDO(k.DO.Clauses(conds...))
}

func (k kmExpansionKeywordDo) Returning(value interface{}, columns ...string) *kmExpansionKeywordDo {
	return k.withDO(k.DO.Returning(value, columns...))
}

func (k kmExpansionKeywordDo) Not(conds ...gen.Condition) *kmExpansionKeywordDo {
	return k.withDO(k.DO.Not(conds...))
}

func (k kmExpansionKeywordDo) Or(conds ...gen.Condition) *kmExpansionKeywordDo {
	return k.withDO(k.DO.Or(conds...))
}

func (k kmExpansionKeywordDo) Select(conds ...field.Expr) *kmExpansionKeywordDo {
	return k.withDO(k.DO.Select(conds...))
}

func (k kmExpansionKeywordDo) Where(conds ...gen.Condition) *kmExpansionKeywordDo {
	return k.withDO(k.DO.Where(conds...))
}

func (k kmExpansionKeywordDo) Order(conds ...field.Expr) *kmExpansionKeywordDo {
	return k.withDO(k.DO.Order(conds...))
}

func (k kmExpansionKeywordDo) Distinct(cols ...field.Expr) *kmExpansionKeywordDo {
	return k.withDO(k.DO.Distinct(cols...))
}

func (k kmExpansionKeywordDo) Omit(cols ...field.Expr) *kmExpansionKeywordDo {
	return k.withDO(k.DO.Omit(cols...))
}

func (k kmExpansionKeywordDo) Join(table schema.Tabler, on ...field.Expr) *kmExpansionKeywordDo {
	return k.withDO(k.DO.Join(table, on...))
}

func (k kmExpansionKeywordDo) LeftJoin(table schema.Tabler, on ...field.Expr) *kmExpansionKeywordDo {
	return k.withDO(k.DO.LeftJoin(table, on...))
}

func (k kmExpansionKeywordDo) RightJoin(table schema.Tabler, on ...field.Expr) *kmExpansionKeywordDo {
	return k.withDO(k.DO.RightJoin(table, on...))
}

func (k kmExpansionKeywordDo) Group(cols ...field.Expr) *kmExpansionKeywordDo {
	return k.withDO(k.DO.Group(cols...))
}

func (k kmExpansionKeywordDo) Having(conds ...gen.Condition) *kmExpansionKeywordDo {
	return k.withDO(k.DO.Having(conds...))
}

func (k kmExpansionKeywordDo) Limit(limit int) *kmExpansionKeywordDo {
	return k.withDO(k.DO.Limit(limit))
}

func (k kmExpansionKeywordDo) Offset(offset int) *kmExpansionKeywordDo {
	return k.withDO(k.DO.Offset(offset))
}

func (k kmExpansionKeywordDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *kmExpansionKeywordDo {
	return k.withDO(k.DO.Scopes(funcs...))
}

func (k kmExpansionKeywordDo) Unscoped() *kmExpansionKeywordDo {
	return k.withDO(k.DO.Unscoped())
}

func (k kmExpansionKeywordDo) Create(values ...*sql_model.KmExpansionKeyword) error {
	if len(values) == 0 {
		return nil
	}
	return k.DO.Create(values)
}

func (k kmExpansionKeywordDo) CreateInBatches(values []*sql_model.KmExpansionKeyword, batchSize int) error {
	return k.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (k kmExpansionKeywordDo) Save(values ...*sql_model.KmExpansionKeyword) error {
	if len(values) == 0 {
		return nil
	}
	return k.DO.Save(values)
}

func (k kmExpansionKeywordDo) First() (*sql_model.KmExpansionKeyword, error) {
	if result, err := k.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*sql_model.KmExpansionKeyword), nil
	}
}

func (k kmExpansionKeywordDo) Take() (*sql_model.KmExpansionKeyword, error) {
	if result, err := k.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*sql_model.KmExpansionKeyword), nil
	}
}

func (k kmExpansionKeywordDo) Last() (*sql_model.KmExpansionKeyword, error) {
	if result, err := k.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*sql_model.KmExpansionKeyword), nil
	}
}

func (k kmExpansionKeywordDo) Find() ([]*sql_model.KmExpansionKeyword, error) {
	result, err := k.DO.Find()
	return result.([]*sql_model.KmExpansionKeyword), err
}

func (k kmExpansionKeywordDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*sql_model.KmExpansionKeyword, err error) {
	buf := make([]*sql_model.KmExpansionKeyword, 0, batchSize)
	err = k.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (k kmExpansionKeywordDo) FindInBatches(result *[]*sql_model.KmExpansionKeyword, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return k.DO.FindInBatches(result, batchSize, fc)
}

func (k kmExpansionKeywordDo) Attrs(attrs ...field.AssignExpr) *kmExpansionKeywordDo {
	return k.withDO(k.DO.Attrs(attrs...))
}

func (k kmExpansionKeywordDo) Assign(attrs ...field.AssignExpr) *kmExpansionKeywordDo {
	return k.withDO(k.DO.Assign(attrs...))
}

func (k kmExpansionKeywordDo) Joins(fields ...field.RelationField) *kmExpansionKeywordDo {
	for _, _f := range fields {
		k = *k.withDO(k.DO.Joins(_f))
	}
	return &k
}

func (k kmExpansionKeywordDo) Preload(fields ...field.RelationField) *kmExpansionKeywordDo {
	for _, _f := range fields {
		k = *k.withDO(k.DO.Preload(_f))
	}
	return &k
}

func (k kmExpansionKeywordDo) FirstOrInit() (*sql_model.KmExpansionKeyword, error) {
	if result, err := k.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*sql_model.KmExpansionKeyword), nil
	}
}

func (k kmExpansionKeywordDo) FirstOrCreate() (*sql_model.KmExpansionKeyword, error) {
	if result, err := k.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*sql_model.KmExpansionKeyword), nil
	}
}

func (k kmExpansionKeywordDo) FindByPage(offset int, limit int) (result []*sql_model.KmExpansionKeyword, count int64, err error) {
	result, err = k.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = k.Offset(-1).Limit(-1).Count()
	return
}

func (k kmExpansionKeywordDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = k.Count()
	if err != nil {
		return
	}

	err = k.Offset(offset).Limit(limit).Scan(result)
	return
}

func (k kmExpansionKeywordDo) Scan(result interface{}) (err error) {
	return k.DO.Scan(result)
}

func (k kmExpansionKeywordDo) Delete(models ...*sql_model.KmExpansionKeyword) (result gen.ResultInfo, err error) {
	return k.DO.Delete(models)
}

func (k *kmExpansionKeywordDo) withDO(do gen.Dao) *kmExpansionKeywordDo {
	k.DO = *do.(*gen.DO)
	return k
}
